Q1

fact:
    addi  $sp, $sp, -8
    sw  $ra, 4($sp)
    sw  $a0, 0($sp)

    slti  $t0, $a0, 1
    bne  $t0, $zero, $base_case

    addi $a0, $a0, -1
    jal fact 
    lw $a0, 0($sp)
    mul $v0, $a0, $v0

    j end 

base_case:
    li $v0, 1

end
    lw $ra, 4($sp)
    addi $sp, $sp, 8
    jr $ra 


Q2

32 bit binary 00000000 00011101 10001000 10010000
hex 0x001D8890

lui $s0, 0x001D
ori $s0, $s0, 0x88900(bỏ số 0 cuối)


Q3

lw $t0, 40($s1) 
=> binary 100011 10001 01000 0000 0000 0010 1000
=> Hex: 0x8E280028
=> Big-endian: 8E 28 00 28

addi $s3, $t0, 8
=> binary 001000 01000 10000 0000 0000 0000 1000
=> Hex: 0x21080008
=> Big-endian: 21 08 00 08



Q4

0x00af8020 = 000000 01011 11100 00000 00000 100000
opcode = 000000 (R-type)
rs = 01011 = 11 => $t3
rt = 11100 = 28 => $gp
rd = 00000 = $zero
funct = 100000 = 32 => add 
===> add $zero, $t3, $gp 


Q5

PUSH A 
PUSH B 
SUB

PUSH C 
PUSH D 
ADD 
DIV

POP X


Q8

step 0: A=0000, Q=0011, Q-1=0 → Q0Q-1 = 10 → A = A - M = 1110
step 1: Shift → A=1111, Q=0001, Q-1=1
step 2: Q0Q-1 = 11 → NOP, Shift → A=1111, Q=1000, Q-1=1
step 3: Q0Q-1 = 01 → A = A + M = 0001
step 4: Shift → A=0000, Q=1100, Q-1=0
Product = A Q = 0000 0110 = 6




Q9

step 0: A = 0000, Q = 1110, Q-1 = 0 → Q0Q-1 = 10 → A = A - M = 1110
step 1: Shift → A = 1111, Q = 1111, Q-1 = 0
step 2: Q0Q-1 = 11 → NOP, Shift → A = 1111, Q = 1111, Q-1 = 1
step 3: Q0Q-1 = 11 → NOP, Shift → A = 1111, Q = 1111, Q-1 = 1
step 4: Shift → A = 1111, Q = 1111, Q-1 = 1
Product: A Q = 11111111 = -4



Q10

step	A(Remainder)	Q(Quotient)	    Q₋₁	    M(Divisor)
step 0	    0000	        0111	     0	    0011
step 1	    1110	        0111	     0	    0011
step 2	    0000	        1110	     1	    0011
step 3	    0000	        1101	     1	    0011
step 4	    0000	        1011	     1	    0011
step 5	    0000	        0111	     1	    0011